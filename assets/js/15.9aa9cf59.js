(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{324:function(a,s,h){"use strict";h.r(s);var e=h(6),t=Object(e.a)({},(function(){var a=this,s=a._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"为什么重写equals方法时必须重写hashcode方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么重写equals方法时必须重写hashcode方法"}},[a._v("#")]),a._v(" 为什么重写equals方法时必须重写HashCode方法")]),a._v(" "),s("h2",{attrs:{id:"一、hashcode是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一、hashcode是什么"}},[a._v("#")]),a._v(" 一、Hashcode是什么？")]),a._v(" "),s("h3",{attrs:{id:"_1、hash和hash表是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1、hash和hash表是什么"}},[a._v("#")]),a._v(" 1、Hash和Hash表是什么？")]),a._v(" "),s("p",[s("strong",[a._v("Hash是指把任意长度的内容，根据已有的转化规则，得到相同长度的一串内容")]),a._v("。")]),a._v(" "),s("p",[a._v("Hash,一般翻译做散列、杂凑，或音译为哈希，是把任意长度的输入（又叫做预映射pre-image）通过散列算法变换成固定长度的输出，输出就是散列值。")]),a._v(" "),s("p",[a._v("这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间。")]),a._v(" "),s("p",[a._v("哈希算法不过是一个更为复杂的运算，它的输入可以是字符串，可以是数据，可以是任何文件，经过哈希运算后，变成一个固定长度的输出，该输出就是哈希值。但是哈希算法有一个很大的特点，就是你不能从结果推算出输入,所以又称为不可逆的算法。")]),a._v(" "),s("p",[a._v("常见的有SHA1、SHA256、MD5、TIGER等等，它们采用不同的一些算法来实现这个功能，不同的Hash算法得到的结果也不一定相同，但是同一个Hash算法对指定内容的结果必须相同。")]),a._v(" "),s("p",[a._v("比如程序中常用的密码存储常采用MD5算法。用户在注册的时候，输入明文密码串，但是数据库存储的并不是这一串明文密码，而是经过MD5算法转换的固定长度字符串。用户在登录的时候，重新输入明文密码，在验证的时候，对该明文进行MD5算法转化，然后再与数据库的密码进行比较，来确定用户身份。")]),a._v(" "),s("p",[a._v("这样做的好处就是防止明文密码泄露，如果是明文存储，那么一旦数据库发生泄露或者被人意外看见，很容易就可以堂而皇之地进行账号登录，非常不安全。目前的App或者网站设计中，一般已经很少见到明文存储的密码数据库了，如果有，那黑客可能非常喜欢。")]),a._v(" "),s("p",[a._v("另外在数据传输领域，Hash也可以很好地用来快速检验数据丢包的问题，在数据发送前把数据内容进行Hash计算并把这个值一并传给接收方，同时在接受方同样对数据内容进行Hash计算，如果两边Hash值不一致，就能知道数据在传输过程中发生了错误。")]),a._v(" "),s("h3",{attrs:{id:"_2、hashcode"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2、hashcode"}},[a._v("#")]),a._v(" 2、Hashcode")]),a._v(" "),s("ul",[s("li",[s("strong",[a._v("而Hashcode的存在是为了提高哈希容器的性能")])]),a._v(" "),s("li",[s("strong",[a._v("Hashcode是通过某一种算法得到的，Hashcode就是在Hash表中有对应的位置。")])]),a._v(" "),s("li",[s("strong",[a._v("不同的内容有可能生成一样的Hash Code，但是不同的Hash Code必然对应不同的内容。")])])]),a._v(" "),s("p",[a._v("也就是说Hash只能从已知内容获得一串固定的Hash Code，但不能从一串固定的Hash Code反推已知内容，所以Hash Code和已知内容之间不是简单的key-value一一对应关系。")]),a._v(" "),s("p",[a._v("在程序中Hash也经常使用，有一定开发经验的人肯定重写过hashCode函数，这个hashCode()方法，产生的是对象的Hash值，在Java中如果使用了散列集合，比如HashMap、HashSet、HashTable等等，在插入的时候，都会调用hashCode()并获得这个对象的Hash值作为一个主键。")]),a._v(" "),s("h2",{attrs:{id:"二、equals方法和hashcode的关系"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二、equals方法和hashcode的关系"}},[a._v("#")]),a._v(" 二、equals方法和hashcode的关系？")]),a._v(" "),s("p",[a._v("通过前面这个例子，大概可以知道，先通过hashcode来比较，如果hashcode相等，那么就用equals方法来比较两个对象是否相等。")]),a._v(" "),s("p",[a._v("用个例子说明：上面说的hash表中的8个位置，就好比8个桶，每个桶里能装很多的对象，对象A通过hash函数算法得到将它放到1号桶中，当然肯定有别的对象也会放到1号桶中，如果对象B也通过算法分到了1号桶，那么它如何识别桶中其他对象是否和它一样呢，这时候就需要equals方法来进行筛选了。")]),a._v(" "),s("ul",[s("li",[a._v("如果两个对象equals相等，那么这两个对象的HashCode一定也相同")]),a._v(" "),s("li",[a._v("如果两个对象的HashCode相同，不代表两个对象就相同，只能说明这两个对象在散列存储结构中，存放于同一个位置")])]),a._v(" "),s("h2",{attrs:{id:"三、为什么equals方法重写的话-建议也一起重写hashcode方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#三、为什么equals方法重写的话-建议也一起重写hashcode方法"}},[a._v("#")]),a._v(" 三、为什么equals方法重写的话，建议也一起重写hashcode方法？")]),a._v(" "),s("blockquote",[s("p",[a._v("如果对象的equals方法被重写，那么对象的HashCode方法也尽量重写")])]),a._v(" "),s("p",[a._v("举个例子，其实就明白了这个道理，")]),a._v(" "),s("p",[a._v("比如：有个A类重写了equals方法，但是没有重写hashCode方法，看输出结果，对象a1和对象a2使用equals方法相等，按照上面的hashcode的用法，那么他们两个的hashcode肯定相等，但是这里由于没重写hashcode方法，他们两个hashcode并不一样，"),s("strong",[a._v("所以，我们在重写了equals方法后，尽量也重写了hashcode方法，通过一定的算法，使他们在equals相等时，也会有相同的hashcode值。")])]),a._v(" "),s("p",[s("img",{attrs:{src:"https://picgo-1307188483.cos.ap-nanjing.myqcloud.com/image-20220808164803838.png",alt:"image-20220808164803838"}})]),a._v(" "),s("p",[a._v("实例：现在来看一下String的源码中的equals方法和hashcode方法。这个类就重写了这两个方法，现在为什么需要重写这两个方法了吧？")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://picgo-1307188483.cos.ap-nanjing.myqcloud.com/image-20220808164826434.png",alt:"image-20220808164826434"}})]),a._v(" "),s("h3",{attrs:{id:"equals"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#equals"}},[a._v("#")]),a._v(" equals")]),a._v(" "),s("p",[a._v("其实跟我上面写的那个例子是一样的原理，所以通过源码又知道了String的equals方法验证的是两个字符串的值是否一样。还有Double类也重写了这些方法。很多类有比较这类的，都重写了这两个方法，因为在所有类的父类Object中。equals的功能就是 “==”号的功能。你们还可以比较String对象的equals和==的区别啦。这里不再说明。")]),a._v(" "),s("h3",{attrs:{id:"hashcode"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashcode"}},[a._v("#")]),a._v(" hashcode")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://picgo-1307188483.cos.ap-nanjing.myqcloud.com/image-20220808164845771.png",alt:"image-20220808164845771"}})]),a._v(" "),s("p",[a._v("参考链接/转载自：")]),a._v(" "),s("p",[a._v("https://zhuanlan.zhihu.com/p/88996672")]),a._v(" "),s("p",[a._v("https://blog.csdn.net/weixin_38405253/article/details/91922340")])])}),[],!1,null,null,null);s.default=t.exports}}]);