---
title: 为什么重写equals方法时必须重写HashCode方法
date: 2022-08-08 16:53:09
permalink: /pages/7ab38d/
categories:
  - 编程资料
  - JAVA学习笔记
  - 面试题库
tags:
  - 
author: 
  name: Ayden
  link: https://github.com/AydenLii
---
# 为什么重写equals方法时必须重写HashCode方法

## 一、Hashcode是什么？

### 1、Hash和Hash表是什么？　　　

**Hash是指把任意长度的内容，根据已有的转化规则，得到相同长度的一串内容**。

Hash,一般翻译做散列、杂凑，或音译为哈希，是把任意长度的输入（又叫做预映射pre-image）通过散列算法变换成固定长度的输出，输出就是散列值。

这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间。

哈希算法不过是一个更为复杂的运算，它的输入可以是字符串，可以是数据，可以是任何文件，经过哈希运算后，变成一个固定长度的输出，该输出就是哈希值。但是哈希算法有一个很大的特点，就是你不能从结果推算出输入,所以又称为不可逆的算法。

常见的有SHA1、SHA256、MD5、TIGER等等，它们采用不同的一些算法来实现这个功能，不同的Hash算法得到的结果也不一定相同，但是同一个Hash算法对指定内容的结果必须相同。

比如程序中常用的密码存储常采用MD5算法。用户在注册的时候，输入明文密码串，但是数据库存储的并不是这一串明文密码，而是经过MD5算法转换的固定长度字符串。用户在登录的时候，重新输入明文密码，在验证的时候，对该明文进行MD5算法转化，然后再与数据库的密码进行比较，来确定用户身份。

这样做的好处就是防止明文密码泄露，如果是明文存储，那么一旦数据库发生泄露或者被人意外看见，很容易就可以堂而皇之地进行账号登录，非常不安全。目前的App或者网站设计中，一般已经很少见到明文存储的密码数据库了，如果有，那黑客可能非常喜欢。

另外在数据传输领域，Hash也可以很好地用来快速检验数据丢包的问题，在数据发送前把数据内容进行Hash计算并把这个值一并传给接收方，同时在接受方同样对数据内容进行Hash计算，如果两边Hash值不一致，就能知道数据在传输过程中发生了错误。

### 2、Hashcode　

- **而Hashcode的存在是为了提高哈希容器的性能**
- **Hashcode是通过某一种算法得到的，Hashcode就是在Hash表中有对应的位置。**
- **不同的内容有可能生成一样的Hash Code，但是不同的Hash Code必然对应不同的内容。**

也就是说Hash只能从已知内容获得一串固定的Hash Code，但不能从一串固定的Hash Code反推已知内容，所以Hash Code和已知内容之间不是简单的key-value一一对应关系。

在程序中Hash也经常使用，有一定开发经验的人肯定重写过hashCode函数，这个hashCode()方法，产生的是对象的Hash值，在Java中如果使用了散列集合，比如HashMap、HashSet、HashTable等等，在插入的时候，都会调用hashCode()并获得这个对象的Hash值作为一个主键。

## 二、equals方法和hashcode的关系？

通过前面这个例子，大概可以知道，先通过hashcode来比较，如果hashcode相等，那么就用equals方法来比较两个对象是否相等。

用个例子说明：上面说的hash表中的8个位置，就好比8个桶，每个桶里能装很多的对象，对象A通过hash函数算法得到将它放到1号桶中，当然肯定有别的对象也会放到1号桶中，如果对象B也通过算法分到了1号桶，那么它如何识别桶中其他对象是否和它一样呢，这时候就需要equals方法来进行筛选了。

- 如果两个对象equals相等，那么这两个对象的HashCode一定也相同
- 如果两个对象的HashCode相同，不代表两个对象就相同，只能说明这两个对象在散列存储结构中，存放于同一个位置

## 三、为什么equals方法重写的话，建议也一起重写hashcode方法？

> 如果对象的equals方法被重写，那么对象的HashCode方法也尽量重写

举个例子，其实就明白了这个道理，

比如：有个A类重写了equals方法，但是没有重写hashCode方法，看输出结果，对象a1和对象a2使用equals方法相等，按照上面的hashcode的用法，那么他们两个的hashcode肯定相等，但是这里由于没重写hashcode方法，他们两个hashcode并不一样，**所以，我们在重写了equals方法后，尽量也重写了hashcode方法，通过一定的算法，使他们在equals相等时，也会有相同的hashcode值。**

![image-20220808164803838](https://picgo-1307188483.cos.ap-nanjing.myqcloud.com/image-20220808164803838.png)

实例：现在来看一下String的源码中的equals方法和hashcode方法。这个类就重写了这两个方法，现在为什么需要重写这两个方法了吧？

![image-20220808164826434](https://picgo-1307188483.cos.ap-nanjing.myqcloud.com/image-20220808164826434.png)

### equals

其实跟我上面写的那个例子是一样的原理，所以通过源码又知道了String的equals方法验证的是两个字符串的值是否一样。还有Double类也重写了这些方法。很多类有比较这类的，都重写了这两个方法，因为在所有类的父类Object中。equals的功能就是 “==”号的功能。你们还可以比较String对象的equals和==的区别啦。这里不再说明。

### hashcode

![image-20220808164845771](https://picgo-1307188483.cos.ap-nanjing.myqcloud.com/image-20220808164845771.png)

参考链接/转载自：

https://zhuanlan.zhihu.com/p/88996672

https://blog.csdn.net/weixin_38405253/article/details/91922340
